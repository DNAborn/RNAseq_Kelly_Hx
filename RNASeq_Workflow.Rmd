---
title: "RNASeq_Workflow"
output:
  github_document:
    html_preview: false
    toc: true
    toc_depth: 4
knit: (function(input_file, encoding) {
    rmarkdown::render(input_file,output_file= 'README.md')
    })
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### 1. R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>. A Markdown is defined by its yaml header on top with code between upper and lower three lines (---). The header in this document is configured in a way that it creates a seperate file called README.md that can be displayed at github.  

A markdown consists of different "chunks" of code that are between three apostrophes (```) at the top of a chunk, the language needs to be defined (r, bash etc.). The header can also include different operators such as include, eval etc. These operators are needed for knitting of the document. Knitting converts the code into a single document with the option to exclude chunks of code (include = FALSE) or to don't evaluate them (eval = FALSE). In this document, all headers are set to eval = FALSE, so that no code is run but all is displayed. 

### 2. Github

Github is a platform that allows to create, store, manage and share code. We use it to organize our different RNASeq projects and share it with collaborators.  

After creating an account and logging in to github <https://github.com>, a new repository can be created under "Repositories" and "New". The name can be set, privacy settings changed and a README file can already be created as well as a .gitignore file specifically for R. The .gitignore file contains different extensions git should ignore and not upload to github. 

#### 2.1. Setup in R Studio

The R markdowns (.Rmd), knitted markdowns (.md) and image output, folder structure etc. can be uploaded to github and browsed there. A new repository can be added to R Studio via R Studio File -> New Project -> Version control. In order to upload files, R Studio and Github need to communicate. The easiest way is via a private key, or personal access token (PAT). A PAT can be generated in Github or in R studio directly via following command:

```{r, eval=FALSE}

# if not already done, install and load usethis package
# install.packages("usethis")
# library(usethis)

usethis::create_github_token()

```

Save the generated key in a seperate text file where it can be accessed all time. 
To upload files, they need to be committed (Ctrl + Alt + M). To commit an item, it first needs to be staged and a commit message needs to be defined. After that, the current data from Github should be pulled and then all data pushed to github. If R Studio asks for a Github username or password, the PAT can be inserted. 

### 3. Setup for RNASeq

This tutorial assumes that R Studio runs on a virtual linux machine and all proxies (http://proxy.charite.de:8080) are set beforehand. 

#### 3.1. Load necessary libraries in R

Initially BiocManager should be installed, after that, all packages can be installed using BiocManager::install(). The following chunk contains all needed packages to run a typical RNA-Seq Project. 

```{r libraries, error=FALSE, warning=FALSE, message=FALSE}
# Initially:
# install.packages("BiocManager")
# BiocManager::install("kableExtra") 

# Startup sequence:

# Basic packages:
library(devtools)
library(BiocManager)
library(tidyverse)

# RNASeq specific
library(tximeta)
library(tximport)
library(BiocFileCache)
library(SummarizedExperiment)
library(AnnotationHub)
library(DESeq2)
library(clusterProfiler)
library(biomaRt)
library(GOSemSim)
library(GOSim)

# Organism specific
library(org.Hs.eg.db)
library(org.Mm.eg.db)

# Data Visualization
library(RColorBrewer)
library(ggplot2)
library(pheatmap)
library(cowplot)
library(EnhancedVolcano)
library(gridExtra)
library(grid)
library(VennDiagram)
library(patchwork)
library(ggdendro)
library(ggfortify)
library(kableExtra)
library(RColorBrewer)
library(viridis)
library(vsn)
library(PCAtools)

# This part can be used to load an own set of functions stored in an utility R document
# source("/mnt/s/AG/AG-Scholz-NGS/Daten/Tobias/GATA4_analysis_git/GATA4-analysis/utils.R", local = knitr::knit_global())

# This code is needed to supress the generation of .log files by VennDiagram package
futile.logger::flog.threshold(futile.logger::ERROR, name = "VennDiagramLogger")

# This code checks the default system and stores the path in a variable for easy swithing between systems if necessary
ifelse(Sys.info()["sysname"]== "Linux",
       s <- "/mnt/s",
       s <- "S:")
dir <- paste(s,"AG/AG-Scholz-NGS/Daten/Tobias/WT1_gonads_git/RNASeq_Workflow/",sep="/")
list.files(dir) %>% head()
```

#### 3.2. Set up conda and salmon

Mapping of RNASeq data is performed by using salmon: <https://combine-lab.github.io/salmon/>. To obtain salmon, anaconda3, mamba or a similar package manager should be installed. e.g. <https://docs.anaconda.com/free/anaconda/install/linux/>. 

```{bash, eval = FALSE}

# Update before use:
conda update conda

# Install the latest salmon version in its own conda environment:
conda config --add channels conda-forge
conda config --add channels bioconda
conda create -n salmon salmon

# To activate salmon:
conda activate salmon
# The name in the console should now read "salmon" instead of "base"

```

### 4. Mapping in Salmon

For mapping in Salmon a local index is needed.  
Ref1: <https://salmon.readthedocs.io/en/latest/salmon.html#preparing-transcriptome-indices-mapping-based-mode>  
Ref2: <https://combine-lab.github.io/alevin-tutorial/2019/selective-alignment/>


#### 4.1. Index current genome version

Download manually:
Go to <http://ftp.ensembl.org/pub/current_fasta/>  

Chooose organism e.g. mus_musculus  
dna ->     <http://ftp.ensembl.org/pub/current_fasta/mus_musculus/dna/> and download the primary assembly (not sm or rm, for more info see readme <http://ftp.ensembl.org/pub/current_fasta/mus_musculus/dna/README>)  
cdna ->    <http://ftp.ensembl.org/pub/current_fasta/mus_musculus/cdna/> and Mus_musculus.GRCm39.cdna.all.fa.gz  
ncrna ->   <http://ftp.ensembl.org/pub/current_fasta/mus_musculus/ncrna/> and downloadMus_musculus.GRCm39.ncrna.fa.gz	  


```{bash, eval=FALSE}
# make a directory at preferred place 
# change according to assayed organism

mkdir mouse
cd mouse

wget -P mouse http://ftp.ensembl.org/pub/current_fasta/mus_musculus/dna/Mus_musculus.GRCm39.dna.primary_assembly.fa.gz
wget -P mouse http://ftp.ensembl.org/pub/current_fasta/mus_musculus/cdna/Mus_musculus.GRCm39.cdna.all.fa.gz
wget -P mouse http://ftp.ensembl.org/pub/current_fasta/mus_musculus/ncrna/Mus_musculus.GRCm39.ncrna.fa.gz

# create list of chromosomes
grep "^>" <(gunzip -c Mus_musculus.GRCm39.dna.primary_assembly.fa.gz) | cut -d " " -f 1 > decoys_mouse_ensm39.txt

# the created .txt contains ">" in front of all chromosomes, use to remove:
sed -i.bak -e 's/>//g' ~/decoys/decoys_mouse_ensm39.txt

# check that ">" is removed
vim decoys_mouse_ensm39.txt
# to exit vim: press Esc -> :q -> Enter

# Combine the different files
cat Mus_musculus.GRCm39.cdna.all.fa.gz Mus_musculus.GRCm39.ncrna.fa.gz Mus_musculus.GRCm39.dna.primary_assembly.fa.gz > gentrome_mouse_ensm39.fa.gz

# make index with salmon
# the number behind -p defines the number of cores used to index. Currently (04/2024) 10 is the maximum... this is weird. If you use more, an index is generated but some data is missing, leading to downstream problems.
salmon index -t gentrome_mouse_ensm39.fa.gz -d decoys_mouse_ensm39.txt -p 10 -i ../../index/mouse_ensm39_index

```

#### 4.2. Check files before mapping

Mapping of reads can be done by different approaches. First the type of sequencing data needs to be assessed:
Paired end (R1 and R2) or single end (R1)?  
Several lanes and replicates or single sequencing?  
For different filenames, cases and combinations the following shell scripts need adaption. First, we generate a test-script to check if we access the right files.

```{bash, eval=FALSE}

# change directory to project folder using cd

# create empty shell script
touch mapping_test.sh

# open and modify shell script
nano mapping_test.sh
```

##### 4.2.1. Mapping test for paired end

Write and adapt the following chunk into the shell script. Change file path "/mnt/s/.../.../.../" to designated path.

```{bash, eval=FALSE}
# This part loops over the files in the specified folder and looks for files containing the string "_R1"
for fn in  /mnt/s/.../.../.../*_R1*;
	do
	# Adjust cut length by changing second integer to needed value (before R1 or R2)
	samp=$(echo "`basename ${fn}`" | cut -c1-20);
	# This part stores the filename for R1 and R2 in the respective variables
	R1=$fn;
	R2=$(echo "`dirname ${fn}`""/""$samp""_R2_001.fastq.gz");
	# This part tests if the files exist
	echo "Processing Sample: $samp";
	test -f $R1 && echo "--> File: $R1 exists"
	test -f $R2 && echo "--> File: $R2 exists"
done
```

After inserting the script, close nano (Strg + X) -> y -> Enter. 

```{bash, eval = FALSE}
# Run script using:

bash mapping_test.sh

```

##### 4.2.2. Mapping test for single end

Write and adapt the following chunk into the shell script. Change file path "/mnt/s/.../.../.../" to designated path.

```{bash, eval=FALSE}
# This part loops over the files in the specified folder and looks for files containing the string "_R1"
for fn in  /mnt/s/.../.../.../*_R1*;
	do
	# Adjust cut length by changing second integer to needed value (before R1 or R2)
	samp=$(echo "`basename ${fn}`" | cut -c1-20);
	# This part stores the filename for R1 and R2 in the respective variables
	R1=$fn;
	# This part tests if the files exist
	echo "Processing Sample: $samp";
	test -f $R1 && echo "--> File: $R1 exists"
done
```

After inserting the script, close nano (Strg + X) -> y -> Enter. 

```{bash, eval = FALSE}
# Run script using:

bash mapping_test.sh

```

##### 4.2.3. Mapping test for subset of single end replicates

This is a special case, where only specific files are needed. Here, only the files containing the substring "L006" are used. It is then checked if the complementary file with the substring "L007" exists. Both files are the same sample, just sequenced on different lanes and will be used together to quantify expression. Change file path "/mnt/s/.../.../.../" to designated path.

```{bash, eval=FALSE}
# Filter only for Files with the substring "l006"
for fn in /mnt/s/.../.../.../*L006*;
	do
	# Filter only for the files 001 - 006
	if [[ $fn == +(*001_S*|*002_S*|*003_S*|*004_S*|*005_S*|*006_S*) ]]
		then
		samp=$(echo "`basename ${fn}`" | cut -c1-12);
		L6=$fn;
		L7=$(echo "`dirname ${fn}`""/""$samp""_L007_R1_001.fastq.gz");
		# Check if for each file with the substring "L006" another file with the substring "L007" exists
		echo "Processing Sample: $samp";
		test -f $R1 && echo "--> File: $L6 exists"
		test -f $R2 && echo "--> File: $L7 exists"
	fi
done
```

After inserting the script, close nano (Strg + X) -> y -> Enter. 

```{bash, eval = FALSE}
# Run script using:

bash mapping_test.sh

```

#### 4.3. Map files

After establishing that all files are present, mapping is performed using salmon. A detailed overview of Salmon functions can be found under <https://readthedocs.org/projects/salmon/downloads/pdf/stable/>.  

Note: it is highly advantageous to combine technical replicates already in this stage. More detailes on this can be found under:  
[4.3.3. Mapping for subset of single end replicates](#433-Mapping-for-subset-of-single-end-replicates)

The general syntax follows this scheme:

```{bash, eval = FALSE}

# dummy-code:
salmon quant -i indexdirectory -l A -r file -p 12 --validateMappings --gcBias -o outputdirectory

# with:
indexdirectory = file path to previously build index
file = file(s) to be mapped
outputdirectory = path to output folder

```

In most cases, changes only need to be made to these three variables.  
To iterate over several files, we write another shell script with:

```{bash, eval=FALSE}

# change directory to project folder using cd

# create empty shell script
touch mapping.sh

# open and modify shell script
nano mapping.sh
```

##### 4.3.1. Mapping for paired end

Write and adapt the following chunk into the shell script. Change file paths "/mnt/s/.../.../.../" to designated path.

```{bash, eval=FALSE}
# This part loops over the files in the specified folder and looks for files containing the string "_R1"
for fn in  /mnt/s/.../.../.../*_R1*;
	do
	# Adjust cut length by changing second integer to needed value (before R1 or R2)
	samp=$(echo "`basename ${fn}`" | cut -c1-20);
	# This part stores the filename for R1 and R2 in the respective variables
	R1=$fn;
	R2=$(echo "`dirname ${fn}`""/""$samp""_R2_001.fastq.gz");
	# This part maps the files. Operators -1 and -2 indicate paired end files.
	salmon quant -i /mnt/s/.../.../.../mouse_ensm39_index -l A \
	-1 $R1 \
	-2 $R2 \
	-p 12 --validateMappings --gcBias -o /mnt/s/.../.../.../quants/${samp}_quant
done
```

After inserting the script, close nano (Strg + X) -> y -> Enter. 

```{bash, eval = FALSE}
# Run script using:

bash mapping.sh

```

##### 4.3.2. Mapping for single end

Write and adapt the following chunk into the shell script. Change file path "/mnt/s/.../.../.../" to designated path.

```{bash, eval=FALSE}
# This part loops over the files in the specified folder and looks for files containing the string "_R1"
for fn in  /mnt/s/.../.../.../*_R1*;
	do
	# Adjust cut length by changing second integer to needed value (before R1 or R2)
	samp=$(echo "`basename ${fn}`" | cut -c1-20);
	# This part stores the filename for R1 and R2 in the respective variables
	R1=$fn;
	# This part tests if the files exist
  salmon quant -i /mnt/s/.../.../.../mouse_ensm39_index -l A $R1 -p 12 --validateMappings --gcBias -o   /mnt/s/.../.../.../quants/${samp}_quant
done
```

After inserting the script, close nano (Strg + X) -> y -> Enter. 

```{bash, eval = FALSE}
# Run script using:

bash mapping.sh

```

##### 4.3.3. Mapping for subset of single end replicates

This is a special case, where only specific files are needed. Here, only the files containing the substring "L006" are used. It is then checked if the complementary file with the substring "L007" exists. Both files are the same sample, just sequenced on different lanes and will be used together to quantify expression. It is important to not use -1 and -2 operators here as this would indicate paired end quantification. Change file path "/mnt/s/.../.../.../" to designated path.

```{bash, eval=FALSE}
# Filter only for Files with the substring "l006"
for fn in /mnt/s/.../.../.../*L006*;
	do
	# Filter only for the files 001 - 006
	if [[ $fn == +(*001_S*|*002_S*|*003_S*|*004_S*|*005_S*|*006_S*) ]]
		then
		samp=$(echo "`basename ${fn}`" | cut -c1-12);
		L6=$fn;
		L7=$(echo "`dirname ${fn}`""/""$samp""_L007_R1_001.fastq.gz");
		# Map each file with the substring "L006" together with the "L007" file
		 if [[ -f "$file" ]]; then
        echo "Processing Sample: $samp";
        salmon quant -i /mnt/s/.../.../.../mouse_ensm39_index -l A -r $L6 $L7 -p 12     --validateMappings --gcBias -o /mnt/s/.../.../.../quants/${samp}_quant
        fi
	fi
done
```

After inserting the script, close nano (Strg + X) -> y -> Enter. 

```{bash, eval = FALSE}
# Run script using:

bash mapping.sh

```

### 5. Check mapping and prepare for tximeta

For this part we will take a look at previously mapped data originating from XX and XY embryonic gonads treated with eiter mismatch or morpholino against GATA4.
To check mapping rates and further build a full data table of our experiment with R:

```{r mapping_rates}
# Check mapping rates
quantfolder <- paste(s,"AG/AG-Scholz-NGS/Daten/embryonic_gonads_GATA4/paired_quants", sep="/")
quantfiles <- list.files(quantfolder, pattern="S")

# Create file lists
samplelist <- {}
mappingrates <- {}

# This loop checks the mapping rates for previously defined files and stores them in a vector
for (i in quantfiles){
  si <- paste("GATA4_Sample",i,sep = " ")
  samplelist <- c(samplelist,si)
  f <- readLines(paste(quantfolder,i,"logs/salmon_quant.log", sep="/"))
  line <- grep("Mapping rate = ",f,value=TRUE)
  sl <- str_length(line)
  sl
  notime <- substring(line,30,sl)
  notime
  manual <- substring(line,sl-7,sl-1)
  val <- as.numeric(str_extract(notime,"[0-9.]+"))
  val
  valr<-round(val, digits=2)
  print(paste("Mapping rate of ",si," is: ",valr," %"))
  mappingrates <- c(mappingrates,valr)
}
```

After good mapping (usually above 70%) is confirmed, a data table with all necessary information should be built.

```{r}
# generate file list & prepare variables
files={}
for (i in list.dirs(path = quantfolder, full.names = TRUE, recursive = FALSE)) {
files <- c(files,paste(i,"/quant.sf",sep=""))
# print(head(read.table(files[length(files)], header=T)))
}

files

# Build table with attributes 
run <- list.files(quantfolder)
# Names should be a meaningful subset of initial run name
names <- paste("GATA4",substring(run,1,3),sep = "_")
# the different tissues are given as factors
organ <- as.factor(rep(c("XY_gonad","XY_gonad","XX_gonad","XX_gonad"),3))
# the different treatments are given as factors
morpho <- as.factor(rep(c("MO","Mis"),6))
# The condition is the combination of our experimental variables
condition <- as.factor(paste(organ,morpho,sep="_"))
# Sample is an easy identifier for visualization and QC
sample <- paste(names,condition,sep="_")
# ID is only needed for paired designs. A nested ID is usually mandatory (see: https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#model-matrix-not-full-rank under: Group-specific condition effects, individuals nested within groups)
ID <- as.factor(c(1,1,2,2,3,3,4,4,5,5,6,6))

# Make table
coldata <- data.frame(files,run, sample, names, organ, morpho, condition, ID, stringsAsFactors=FALSE)
```

The result of this should be a table containing all information that is required to analyze the experiment. This includes but is not limited to, experimental conditions such as treatment, genotype, sex etc. but also statistical information on pairing of data etc. 

```{r coldata}
knitr::kable(head(coldata))
```

### 6. Run Tximeta

Tximeta is used for import and annotation of salmon-quantified data. Full information can be found here: <https://bioconductor.org/packages/release/bioc/vignettes/tximeta/inst/doc/tximeta.html#Introduction>

#### 6.1. Set index and local BFC

Tximeta can be used locally (with a specified index) or via a Hub using the current Ensembl. For the first use, the BiocFileCache (BFC) needs to be set up by running makeLinkedTxome(). 

```{r, eval = FALSE}
# set paths
dirsalmon <- "/mnt/s/AG/AG-Scholz-NGS/Daten/Tobias/Salmon_TS/mouse"
indexDir <- "/mnt/s/AG/AG-Scholz-NGS/Daten/Tobias/Salmon_TS/mouse/mouse_ensm39_index_c1"
fastaPath <- file.path(dirsalmon, "Mus_musculus.GRCm39.dna.primary_assembly.fa.gz")
gtfPath <- file.path(dirsalmon,"Mus_musculus.GRCm39.111.chr.gff3.gz")

file.exists(indexDir, fastaPath, gtfPath)

# This needs to be run for first use!
# make the linked txome and store it in BFC
# makeLinkedTxome(indexDir=indexDir,
#                  source="LocalEnsembl",
#                  organism="Mus musculus",
#                  release="111",
#                  genome="GRCh39",
#                  fasta=fastaPath,
#                  gtf=gtfPath,
#                  write=FALSE)

# use tximeta on coldata and save as summarized experiment se
se <- tximeta(coldata, useHub = FALSE)

se
```

The result will be a summarized experiment file. To illustrate such a file, we will load and display a previously made one. 

```{r}
load("/mnt/s/AG/AG-Scholz-NGS/Daten/Tobias/WT1_gonads_git/RNASeq_Workflow/se.txm")

se
```

SummarizedExperiment files have a complex structure. In this case we have 12 samples with 144602 detected genes (dim). The file also contains metadata, different assays (especially counts is important here) and all other availiable information. The previously made table called "coldata" can now be found in colData(se).

This point is usually a good point to also check for mapping rates and assess quality of the overall mapping process. 
```{r se_QC, fig.show='hold', out.width="50%"}
# Plot data:
# The scale of the y axis can be changed by setting ylim = c(y1,y2) values 

barplot(metadata(se)[["quantInfo"]]$percent_mapped, main="Mapping Rate, all samples", names = colnames(se), las = 2, cex.names = 0.5, ylim = c(0,80))
barplot(metadata(se)[["quantInfo"]]$num_processed/1000000, main="Mio. Reads, all samples", names = colnames(se), las = 2, cex.names = 0.5, ylim = c(0,30))
```


##### 6.1.1. BFC and Tximeta Troubleshooting

Problems in the previous steps are often caused by a problem in BFC:
<https://www.bioconductor.org/packages/release/bioc/manuals/BiocFileCache/man/BiocFileCache.pdf>

```{r, eval = FALSE}
# do not run:

# change "user" to your name
# This sets the tximeta BFC location to the standard value
setTximetaBFC("/home/user/.cache/R/BiocFileCache")

# to check bfc location run:
bfcloc <- getTximetaBFC()

# to change bfc location run:
bfc <- BiocFileCache(bfcloc)

# to check all entries in bfc:
# the space between "" can be used for patterns, e.g. "mus" will show all bfc entries from mouse
bfcquery(bfc, "")

# Remove all entries:
# the space between "" can be used for patterns, e.g. "mus" will remove all bfc entries from mouse
bfcremove(bfc, bfcquery(bfc, "")$rid)

# Sometimes its usefull to not use a local ensembl. in this case, tximeta can fetch data online using:
se <- tximeta(coldata, useHub = TRUE)

```

#### 6.2. Check Summarized experiment and plot data

Here we go through some raw data from the SummarizedExperimen and summarize it to gene level. 
```{r assessing_se, eval=FALSE}
# Extract tximeta file infos (se)

# colData(se) # samples, conditions,...
assayNames(se) # counts
rowRanges(se) # see metadata: Gene_IDs, biotype,..
seqinfo(se)

str(metadata(se)[["quantInfo"]]) # Infos from Salmon Mapping
```

Summarizes abundances, counts, lengths, (and inferential replicates or variance) from transcript- to gene-level.

```{r, eval = FALSE}
# summarize to gene level
gse <- summarizeToGene(se)
```

```{r, include = FALSE}
#this chunk loads a gse, as there where problems with summarizeToGene(se) when ran in knit... sorry
load("/mnt/s/AG/AG-Scholz-NGS/Daten/Tobias/GATA4_analysis_git/dds_files/tximeta_GATA4_paired.txm")

```



#### 6.3 Add annotations to Summarized experiment
Here annotations should be added. For most projects, SYMBOL, ENTREZID and DESCRIPTION are enough. However, additional annotations may be useful.

```{r annotations, message=FALSE, warning=FALSE}
ah = AnnotationHub()
# look for correct version number
query(ah, c("EnsDb", "mus musculus"))
# change annotation hub ID if necessary
edb <- ah[["AH116340"]]
# list possible annotations
columns(edb)

# Add annotations
mcols(gse)$SYMBOL <- mapIds(edb, keys = mcols(gse)$gene_id, column = "SYMBOL", keytype = "GENEID")
mcols(gse)$ENTREZID <- mapIds(edb, keys = mcols(gse)$gene_id, column = "ENTREZID", keytype = "GENEID")
mcols(gse)$CANONICALTRANSCRIPT <- mapIds(edb, keys = mcols(gse)$gene_id, column = "CANONICALTRANSCRIPT", keytype = "GENEID")
mcols(gse)$DESCRIPTION <- mapIds(edb, keys = mcols(gse)$gene_id, column = "DESCRIPTION", keytype = "GENEID")
mcols(gse)$GENEBIOTYPE <- mapIds(edb, keys = mcols(gse)$gene_id, column = "GENEBIOTYPE", keytype = "GENEID")
mcols(gse)$UNIPROTID <- mapIds(edb, keys = mcols(gse)$gene_id, column = "UNIPROTID", keytype = "GENEID")

# change to specified path and save
# save(gse,file="/mnt/s/.../.../.../tximeta.txm")

```

### 7. Compare counts using DESeq2

DESeq2 is used for detection of differentially expressed genes. More information on the general DESeq2 workflow can be found here:
<https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#input-data>.  

To compare different groups correctly, DESeq2 needs a defined model. A good tutorial for most basic comparisons can be found here: <https://rstudio-pubs-static.s3.amazonaws.com/329027_593046fb6d7a427da6b2c538caf601e1.html>.  

For different comparisons, DESeq requires values as reference levels. These reference levels are always the first factor. Therefore it is important to relevel the groups accordingly. To compare the effect of a treatment (treat) against its control (ctrl) it is therefore important to set the factor levels as "ctrl", "treat". If this is not done, and "treat", "ctrl" is forwarded to DESeq, the results will be calculated as the effect of ctrl (i.e. vice versa effect). By default, R chooses the reference level for factors on alphabetical order.

```{r, eval = FALSE}
# General considerations:
# Check levels of factors in coldata.
# e.g. 
levels(gse$morpho)
levels(gse$organ)

# and relevel accordingly:
gse$morpho <- relevel(gse$morpho, "Mis")

```

#### 7.1. Simple DESeq design 

This simple approach can be used to detect changes between two groups with and without treatment. Here we have two organs (XX and XY) and a treatment mismatch (Mis) and morpholino (MO). As we may also be interested in the differences in response to the morpholino between the organs, an interaction term is also included (organ:morpho). 

```{r, eval=FALSE}

dds <- DESeqDataSet(gse, ~ organ + morpho + organ:morpho)

dds <- DESeq(dds) 
resultsNames(dds)

```

This design formula can also be further simplified (in some instances) by only using the condition as this contains already information about the groups.

```{r, eval=FALSE}

dds <- DESeqDataSet(gse, ~ condition)

dds <- DESeq(dds) 
resultsNames(dds)

```


#### 7.2. Design for paired data

If the experiment contains paired samples, DESeq can include this information.
Here, a paired model is used to analyse differences in samples originating from morpholino treatment. 
The full model analyses the influence of the organ i.e. sex and morpholino treatment while adjusting for the nested animal ID. 
For more information on paired models see:  
<https://www.biostars.org/p/447684/>, <https://support.bioconductor.org/p/84241/> and <https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#model-matrix-not-full-rank>.

```{r, eval=FALSE}
# add a nested term for evaluating the full model
gse$animal.nested <- factor(rep(1:3,each=4))

### set DESeq design formula with interaction term
knitr::kable(colData(gse))

# full model for identifying sex differences
dds <- DESeqDataSet(gse, design = ~ organ + organ:animal.nested + organ:morpho)
```

#### 7.3 Filtering of low counts and running DESeq

Before continuing it is useful to filter out the low counts. This can be done by using the sample number as a lower limit of the row sums. This means that only genes are included which counts, summed over all samples equals or is greater than the sample number.  
After filtering these counts out, DESeq should be run.

```{r, eval=FALSE}
sample.number <- nrow(colData(dds))
keep.sn <- rowSums(counts(dds)) >= sample.number

dds <- dds[keep.sn,]

dds <- DESeq(dds)
```

### 8. Generating results with DESeq2

For generating results, i.e. answering the question "what is the treatment effect?" etc. To accurately compare different groups, DESeq2 offers the results() function. After running DESeq, the corresponding comparisons can be printed by calling the reultsNames() function.

```{r, eval=FALSE}

resultsNames(dds)

```

Depending on the design and its complexity, the resultsNames function will return a varying amount of comparisons.

#### 8.1. Result examples

To illustrate a different experimental designs we load the Kelly hypoxia dataset featuring two conditions ("Normoxia" and "Hypoxia") and four genotypes (Kelly, hif1a-ko, hif2a-ko and hif1b-ko). Depending on the scientific question there are (at least) 3 possible ways to generate the results list of differential expressed genes. Deseq2 allows to combine serveral groups and test directly for significant genes

```{r load_example_data}
# Load tximeta file
load(file=paste(s,"AG/AG-Scholz-NGS/Daten/Simon/RNA-Seq_Kelly_all/data/tximeta.txm", sep="/"))
colData(gse) %>% head() %>% kable()

```

##### 8.1.1. Generate dds
For the first comparison, we use a simple design, accounting for an influence of the genotype, treatment and the interaction between them.

```{r run_deseq2, fig.height=8, fig.width=12, warning=FALSE}
# Preapre Deseq2 files
design = ~ genotype + treatment + genotype:treatment
dds <- DESeqDataSet(gse, design = design)

# removal of low counts
dds <- dds[rowSums(counts(dds)) >= 22,]

# Run DESeq2
dds <- DESeq(dds)

```

We can now take a closer look at one example gene, in this case EPO, to get a better understanding of the experimental groups.
```{r example_counts, fig.height=4}

# Plot example counts
gene <- mcols(dds)[mcols(dds)$symbol=="EPO",]$gene_id
plotCounts(dds,gene = gene, intgroup = "condition", col=colData(dds)$treatment, main=paste("EPO (",gene,")",sep=""))

```

If only kelly cells and hif1a cells are taken into account, the different comparisons can be presented as following:

![Contrasts_overview](README_files/Contrasts.png)  

Fig.1: This example graph shows the different approaches to test for genes that show different expression patterns in the hif1a-knockout

This is a simplified version of the different comparisons we may be interested in. To get more specific, DESeq2 uses a different annotation based on reference levels of the design we have supplied. 

```{r results_names}
# Remember the factor level
levels(dds$treatment)
levels(dds$genotype)
# The reference levels are Nx and Kelly

# get results names
resultsNames(dds)

# Show as table
cbind(resultsNames(dds),c(rep(0,length(resultsNames(dds)))))

```

From these reference levels and resultsNames we can get the following combinations:

![Contrasts_overview](README_files/Simple_design.png)
Fig.2: A simple design showing two groups, two treatments and the reference level. Arrows correspond to the resultsNames().

##### 8.1.2. Introduction to results and main effects

Results can be generated in different ways, often with several approaches resulting the same. To get genes that are differentially expressed under hypoxia in kelly cells we can use at least 4 different annotations. To generate the results for Kelly cells, we only need to take the treatment effect into account as Kelly is already set as the reference level (Fig.2). 

```{r results_Kelly}
# We can now test for the treatment effect (Hx vs Nx), which will be on the reference level (Kelly), using either:
results_Kelly_Hx.vs.Nx.A1 <- results(dds, name = "treatment_Hx_vs_Nx")
results_Kelly_Hx.vs.Nx.A2 <- results(dds, contrast = list(c("treatment_Hx_vs_Nx")))

# if we look at the results with 
resultsNames(dds)
# we can also use the following annotation with a 1 at fifth position, indicating the use of the fifth element in resultsNames
results_Kelly_Hx.vs.Nx.A3 <- results(dds, contrast = c(0,0,0,0,1,0,0,0))

# We can also specify the contrast and overrule factor levels by using following annotation. Here we specify that Hx should be tested against Nx. If we swap it to c("treatment", "Nx", "Hx") we will get the effect of normoxia with Hx as reference level.
results_Kelly_Hx.vs.Nx.A4 <- results(dds, contrast = c("treatment", "Hx", "Nx"))
```

To test if these annotations are really the same, we can compare their log2Fold changes:

```{r, figures_results, fig.show="hold", out.width="33%"}
# Check if its the same
plot(x=results_Kelly_Hx.vs.Nx.A1$log2FoldChange, y=results_Kelly_Hx.vs.Nx.A2$log2FoldChange, main="res A1 vs. res A2 = identical")
plot(x=results_Kelly_Hx.vs.Nx.A2$log2FoldChange, y=results_Kelly_Hx.vs.Nx.A3$log2FoldChange, main="res A2 vs. res A3 = identical")
plot(x=results_Kelly_Hx.vs.Nx.A4$log2FoldChange, y=results_Kelly_Hx.vs.Nx.A1$log2FoldChange, main="res A4 vs. res A1 = identical")

```

To generate the results for the treatment effect in Hif1a cells, we also need to include these cells. The term "treatment_Hx_vs_Nx" tests for the treatment effect on reference level (Kelly), therefore we have to change it so it tests the treatment effect on Hif1a level. We can do this by including the interaction term (compare Fig.2):

```{r results_HIF1A,  fig.show="hold", out.width="33%"}
# Get results that are differential expressed under hypoxia in Hif1a cells:
results_Hif1a_Hx.vs.Nx.B1 <- results(dds, contrast = list(c("treatment_Hx_vs_Nx","genotypeHIF1A.treatmentHx")))
results_Hif1a_Hx.vs.Nx.B2 <- results(dds, contrast = c(0,0,0,0,1,1,0,0))

plot(x=results_Hif1a_Hx.vs.Nx.B1$log2FoldChange, y=results_Hif1a_Hx.vs.Nx.B2$log2FoldChange, main="res B1 vs. res B2 = identical")

```

And to compare Kelly hypoxia expression levels with Hif1a hypoxia expression levels (and same for normoxia) we can use:

```{r results_celllines}
# Hypoxia
results_Hx_Hif1a.vs.Kelly <- results(dds, contrast = list(c("genotype_HIF1A_vs_Kelly","genotypeHIF1A.treatmentHx")))
results_Hx_Hif1a.vs.Kelly <- results(dds, contrast = c(0,1,0,0,0,1,0,0))

# Normoxia
results_Nx_Hif1a.vs.Kelly <- results(dds, contrast = list(c("genotype_HIF1A_vs_Kelly")))
results_Nx_Hif1a.vs.Kelly <- results(dds, contrast = c(0,1,0,0,0,0,0,0))
```


From here we have the upon hypoxia differentially expressed genes in Kelly cells and in HIF1A cells. The resulting lists can now be filtered and subsetted to infere the differential effect of the treatment on both celllines.

```{r results_1_2}
# This is ehe hypoxia effect in both cell lines
# Filter for differential expressed genes with cutoff p > 0.05 and log2 fold-change of 1
deg_Kelly_Hx.vs.Nx.A <- subset(results_Kelly_Hx.vs.Nx.A1, padj <= 0.05 & (log2FoldChange >= 1 | log2FoldChange <= -1)) %>% rownames()
deg_Hif1a_Hx.vs.Nx.B <- subset(results_Hif1a_Hx.vs.Nx.B1, padj <= 0.05 & (log2FoldChange >= 1 | log2FoldChange <= -1)) %>% rownames()

# to get differentially expressed genes between conditions we can subset further using setdiff()
results_1_Hx.vs.Nx <- c(
  setdiff(deg_Kelly_Hx.vs.Nx.A,deg_Hif1a_Hx.vs.Nx.B),
  setdiff(deg_Hif1a_Hx.vs.Nx.B,deg_Kelly_Hx.vs.Nx.A))

# This is the cellline effect in both treatments
# filter for deg and combine both lists
# Filter for differential expressed genes with cutoff p > 0.05 and log2 fold-change of 1
deg_Hx_Hif1a.vs.Kelly <- subset(results_Hx_Hif1a.vs.Kelly, padj <= 0.05 & (log2FoldChange >= 1 | log2FoldChange <= -1)) %>% rownames()
deg_Nx_Hif1a.vs.Kelly <- subset(results_Nx_Hif1a.vs.Kelly, padj <= 0.05 & (log2FoldChange >= 1 | log2FoldChange <= -1)) %>% rownames()

results_2_HxHx_NxNx <- c(deg_Hx_Hif1a.vs.Kelly,
                         deg_Nx_Hif1a.vs.Kelly) %>% unique()
```

However, there are more sophisticated ways to get to these results, which are discussed in the following paragraph.  

##### 8.1.3 Difference in response results (interaction term)

Directly test the "interaction" term for differences. I.e. Differences between the hypoxia effect in Kelly with the hypoxia effect in Hif1a.\
The hypoxia effect in Kelly cells: "treatment_Hx_vs_Nx"\
The hypoxia effect in Hif1a cells: "treatment_Hx_vs_Nx" + "genotypeHIF1A.treatmentHx"\
Differences between Hif1a hypoxia effect versus Kelly hypoxia effect:\
("treatment_Hx_vs_Nx" + "genotypeHIF1A.treatmentHx") - "treatment_Hx_vs_Nx"\
= "genotypeHIF1A.treatmentHx"

In 0/1 annotation:\
The hypoxia effect in Kelly cells: c(0,0,0,0,1,0,0,0)\
The hypoxia effect in Hif1a cells: c(0,0,0,0,1,1,0,0)\
Differences between Hif1a hypoxia effect versus Kelly hypoxia effect:\
c(0,0,0,0,1,1,0,0)\
-c(0,0,0,0,1,0,0,0)\
= c(0,0,0,0,0,1,0,0)

-\> Differences of two effects is by definition the "interaction" term!

```{r results_3}

results_KellyHxNx.vs.Hif1aHxNx <- results(dds, contrast = list(c("genotypeHIF1A.treatmentHx")))
results_KellyHxNx.vs.Hif1aHxNx <- results(dds, contrast = c(0,0,0,0,0,1,0,0))

# filter for deg
results_3_HxNx.vs.HxNx <- subset(results_KellyHxNx.vs.Hif1aHxNx, padj <= 0.05 & abs(log2FoldChange) >= 1) %>% rownames()

```

By now we have generated all meaningfull comparisons from this dataset. To compare them we can plot them as a venn diagram:

```{r compare_results, fig.height=4, fig.width=12}

venn <- venn.diagram(list(
  results_1_Hx.vs.Nx,
  results_2_HxHx_NxNx,
  results_3_HxNx.vs.HxNx),
  category.names=c("Res_1","Res_2","Res3"),
  disable.logging = TRUE,
  filename = NULL,
  fill = c("salmon3","seagreen3","orchid3"))
c_graphic <- png::readPNG("README_files/Contrasts.png", native = TRUE)
patchwork::wrap_elements((venn)) + c_graphic

```

#### 8.2. Complex designs

DESeq2 allows the testing of complex contrasts including "group1" vs. "group2". If group1 and group2 comprise of more than 1 effect we have to scale it down to 1. I.e. if group1 consists of two effects we divide it by 2.

![Contrast_groups](README_files/Contrasts_combined.png)

We want to compare the hypoxia effect of both Hif1a and Hif2a against Hif1b.\
Again we build up the contrast step by step:\
Group1: Hypoxia effect of Hif1a (See results 3 in Chapter above) + hypoxia effect of Hif2a\
1A: hypoxia effect in Hif1a: "treatment_Hx_vs_Nx" + "genotypeHIF1A.treatmentHx" or c(0,0,0,0,1,1,0,0)\
1B: hypoxia effect in Hif2a: "treatment_Hx_vs_Nx" + "genotypeHIF2A.treatmentHx" or c(0,0,0,0,1,0,1,0)

In Group1 we have two items, so we divide the effect by 2:\
1A: "genotypeHIF2A.treatmentHx" /2\
1B: "treatment_Hx_vs_Nx" /2 + "genotypeHIF2A.treatmentHx" /2 or c(0,0,0,0,1/2,0,1/2,0)

In sum this is Group1: "treatment_Hx_vs_Nx" + "genotypeHIF1A.treatmentHx"/2 + "genotypeHIF2A.treatmentHx"/2 or c(0,0,0,0,1,1/2,1/2,0)

Group2\
Group2: hypoxia effect in Hif1b: "treatment_Hx_vs_Nx" + "genotypeHIF1B.treatmentHx" or c(0,0,0,0,1,0,0,1)

Group1 vs. Group2 (= Group1 - Group2) ( "treatment_Hx_vs_Nx" + "genotypeHIF1A.treatmentHx"/2 + "genotypeHIF2A.treatmentHx"/2 ) - ( "treatment_Hx_vs_Nx" + "genotypeHIF1B.treatmentHx" ) = "genotypeHIF1A.treatmentHx"/2 + "genotypeHIF2A.treatmentHx"/2 - "genotypeHIF1B.treatmentHx"

or\
c(0,0,0,0,1,1/2,1/2,0) - c(0,0,0,0,1,0,0,1)\
= c(0,0,0,0,0,1/2,1/2,-1)

Let's make the results!

```{r 2vs1, fig.height=4, fig.width=6}

results_HxNx_Hif1a2a.vs.Hif1b.1 <- results(dds, contrast = c(0,0,0,0,0,1/2,1/2,-1))
results_HxNx_Hif1a2a.vs.Hif1b.2 <- results(dds, contrast =
    list(a=c("genotypeHIF1A.treatmentHx","genotypeHIF2A.treatmentHx"),
         b=c("genotypeHIF1B.treatmentHx")),
    listValues = c(0.5,-1))

# Test if its the same
plot(x=results_HxNx_Hif1a2a.vs.Hif1b.1$log2FoldChange, y=results_HxNx_Hif1a2a.vs.Hif1b.2$log2FoldChange, main="res1 vs. res2 = identical")

```


### 9. Quality control

There are some ways to control the quality and it is useful to first check the general quality of the data. This can be done by checking mapping quality first (mapping rate & million reads). Here, a MA-Plot, Dispersion and cooks cutoff are assessed. 

To go through some aspects of QC in RNASeq data, we will take a look again at the dds file from the hypoxia experiments.


```{r QC_dds, fig.show='hold', out.width="33%"}
plotMA(dds)
plotDispEsts(dds)
boxplot(log10(assays(dds)[["cooks"]]), range=0, las=2)
```

For interpretation see here:  
MA-Plot: Points will be colored blue if the adjusted p-value is less than 0.1. Points which fall out of the window are plotted as open triangles pointing either up or down. This plot gives a rough idea about the significance of the overall effect in the dataset. 

Dispersion-Plot: A good explanation can be found here: <https://hbctraining.github.io/DGE_workshop/lessons/04_DGE_DESeq2_analysis.html>, in short: it is good when the red line goes through the blue dots. 

Cooks-Plot: Cooks distance is used to calculate outliers in DESeq2, also see Mike Loves answer here: <https://support.bioconductor.org/p/92428/#92447>. If this plot looks problematic, it could be useful to turn cooksCutoff off: results(dds,cooksCutoff=FALSE). Also check: <https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html> which gives a detailed overview over outlier handling in DESeq2 (Chapter: "Approach to count outliers").

As a next step, it is useful to take a closer look if the data matches the expected behavior of the samples. Here it is interesting if samples that should be close to each other are actually close. If we have a experiment with two genotypes and a treatment, we would expect, 4 seperate groups (the different experimental conditions). The following analysis will reveal if the effects are strong enough to appear in our data. Therefore it is first useful to transform the data and blind it to our experimental design.

The point of these transformations, is to remove the dependence of the variance on the mean, particularly the high variance of the logarithm of count data when the mean is low. The two functions, vst and rlog have an argument blind, for whether the transformation should be blind to the sample information specified by the design formula. When blind equals TRUE (the default), the functions will re-estimate the dispersions using only an intercept. This setting should be used in order to compare samples in a manner wholly unbiased by the information about experimental groups, for example to perform sample QA.

```{r meanSd, fig.show='hold', out.width="33%"}
vsd <- vst(dds, blind=FALSE) #Variance stabilized transformation
rld <- rlog(dds, blind=FALSE) #regularized logarithm
ntd <- normTransform(dds)

meanSdPlot(assay(vsd))
meanSdPlot(assay(rld))
meanSdPlot(assay(ntd))
```

The resulting image plots the mean against the standard deviation. Note that the vertical axis in such plots is the square root of the variance over all samples, so including the variance due to the experimental conditions. While a flat curve of the square root of variance over the mean may seem like the goal of such transformations, this may be unreasonable in the case of datasets with many true differences due to the experimental conditions.  
In this case variance stabilized transformation (vsd) shows the best behaviour. 

After choosing a transformation a first analysis can be a PCA:
```{r, pca, warning = FALSE, message=FALSE, fig.show='hold', out.width="33%"}
### PCA with top 500 genes with highest row variance (standard PCA)
pcaData <- plotPCA(vsd, intgroup=c("genotype", "treatment"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=treatment, shape=genotype)) +
  geom_point(size=3) +
  labs(title = "top 500 variance") +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
  coord_fixed()

# For more detailed PCAs:
# here variance stabilized transformation was used
vst_dat <- assay(vst(dds))

# get ensembl ids
ens <- rownames(dds)
# convert to symbols, remove NAs and transfer to vst data
symbols <- mapIds(org.Hs.eg.db, keys = ens, column = c('SYMBOL'), keytype = 'ENSEMBL')
symbols <- symbols[!is.na(symbols)]
symbols <- symbols[match(rownames(vst_dat), names(symbols))]
rownames(vst_dat) <- symbols
# clean data
keep <- !is.na(rownames(vst_dat))
vst_dat <- vst_dat[keep,]
keep2 <- rownames(vst_dat)
keep2 <- !duplicated(keep2)
vst_dat <- vst_dat[keep2,]

# calculate PCA (all data)
p <- pca(vst_dat, metadata = colData(dds))

# make a biplot 
biplot(p, showLoadings = FALSE,
    labSize = 3, pointSize = 5, sizeLoadingsNames = 2.5,
    title = "biplot containing all datapoints")

# find explaining PCs
horn <- parallelPCA(vst_dat)

# plot Screeplot to determine explaining PCs
screeplot(p,
        components = getComponents(p),
        vline = c(horn$n))+
        geom_label(aes(x = horn$n, y = 50,
        label = 'Horn\'s', vjust = -1, size = 8))
```

In this data it becomes apparent that the groups do mostly seperate within the first two components, explained by genotype and treamtment, looking at the 500 most varying genes. This however gets more blurry if all genes are included. Further shows the Scree Plot the presence of additional influences. 

Another way of assessing the similarity of the samples and finding major influences on variability is to plot the sample-sample distance and cluster samples together. This can be done via:

```{r dist, out.width="50%"}
sampleDists <- dist(t(assay(vsd)))

sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$genotype, vsd$treatment, sep="-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)
```
Here it also becomes visible that there is a clear distinction between Nx and Hx samples.

### 10. Exploratory data analysis

After acquiring the dds and making the corresponding comparisons, the data can be analyzed further to find meaningful DEGs. For the following examples we use two results from the previous hypoxia dataset. For the following parts we will look at the hypoxia response in Kelly cells and Hif1a cells. 

```{r summary}
# hypoxia effect in kelly and hif1a
results_Kelly_Hx.vs.Nx <- results(dds, name = "treatment_Hx_vs_Nx")
results_Hif1a_Hx.vs.Nx <- results(dds, contrast = list(c("treatment_Hx_vs_Nx","genotypeHIF1A.treatmentHx")))

summary(results_Kelly_Hx.vs.Nx, alpha=0.05)
summary(results_Hif1a_Hx.vs.Nx, alpha=0.05)

```

#### 10.1. Outlier handling

It is always a good first idea to check the summary of any given result. Using the alpha argument we can specify a p value cutoff. The summary then shows us the number of significantly changed genes, low count genes and outliers. DESeq determines outliers using cooks distance and removes them by independent filtering. See also: <https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#outlier>. Cooks cutoff starts to be meaningful at three or more samples. Outliers get replaced if the within the design specified groups are larger than n=7. With replicates below n=7, outliers are detected by using the 99% quantile of the distribution and if flagged, their pvalue and p.adjust are set to NA. If there are several hundred to thousand outliers in a dataset, it is advised to check the QC boxplot for the cooks distance to see if one sample is continuously higher. If that is not the case, like in our example, it is up to the own interpretation how the samples should be handled. Basically what DESeq2 does tell you is that it cannot interfere if the statistical effect is significant or not. Using cooks cutoff with only n=3 will therefore yield a large number of outliers but confidence in significant findings is relatively large. For some exploratory analysis however it can be useful to deactivate cooks cutoff, this can be done by:

```{r cooks}

results_Kelly_Hx.vs.Nx_cooks <- results(dds, name = "treatment_Hx_vs_Nx", cooksCutoff = FALSE)
results_Hif1a_Hx.vs.Nx_cooks <- results(dds, contrast = list(c("treatment_Hx_vs_Nx","genotypeHIF1A.treatmentHx")), cooksCutoff = FALSE)

summary(results_Kelly_Hx.vs.Nx_cooks, alpha=0.05)
summary(results_Hif1a_Hx.vs.Nx_cooks, alpha=0.05)

```

As shown, no more outliers are detected and the amount of significant findings almost doubled.With n=3 experiments, a large number of outliers is expected and again, if this filtering is wanted or not solely depends on the granularity and confidence in the exploratory analysis.
